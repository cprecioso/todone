import * as core from "@actions/core";
import * as github from "@actions/github";
import dedent from "dedent";
import { toHtml } from "hast-util-to-html";
import { h } from "hastscript";
import { toMarkdown } from "mdast-util-to-markdown";
import pMap from "p-map";
import { u } from "unist-builder";
import { reconcile } from "./reconciler";
import { ExpiredResult, formatDate, partition } from "./util";

const TODONE_LABEL = "todone";

export const generateIssue = async ({
  result: { url, result, matches },
}: ExpiredResult) => {
  const urlString = url.toString();
  const title = `TODO: ${result.title ?? urlString}`;

  const body = toMarkdown(
    u("root", [
      u("paragraph", [
        u("text", "The following TODO has expired"),
        ...(result.expirationDate
          ? [
              u("text", ` as of `),
              u(
                "html",
                toHtml(
                  h(
                    "time",
                    { datetime: result.expirationDate.toISOString() },
                    formatDate(result.expirationDate),
                  ),
                ),
              ),
            ]
          : []),
        u("text", ":"),
      ]),

      u("list", [
        u("listItem", [
          u("paragraph", [
            ...(result.title
              ? [
                  u("link", { url: urlString }, [u("text", result.title)]),
                  u("break"),
                ]
              : []),
            u("link", { url: urlString }, [u("text", urlString)]),
          ]),
        ]),
      ]),

      u("paragraph", [u("text", "It is present in the following files:")]),

      u(
        "list",
        await pMap(
          matches,
          async (match) => {
            const fileUrl = await match.file.getUrl(match.position.line);

            return u("listItem", [
              u("paragraph", [
                fileUrl
                  ? u("link", { url: fileUrl }, [u("text", fileUrl)])
                  : u(
                      "text",
                      `${match.file.location}:${match.position.line}:${match.position.column}`,
                    ),
              ]),
            ]);
          },
          { concurrency: 1 },
        ),
      ),

      u("thematicBreak", []),

      u("paragraph", [
        u("text", "This issue has been automatically created by "),
        u("inlineCode", { value: "todone" }),
        u("text", "."),
      ]),

      u(
        "html",
        toHtml([
          u(
            "comment",
            "Please do not edit this comment, it is automatically generated by todone.",
          ),
          u("text", "\n"),
          u("comment", `todone ${urlString}`),
        ]),
      ),
    ]),
  );

  return { id: urlString, title, body };
};

const getFinalData = (txt: string) =>
  txt.match(/<!-- todone (.+) -->\s*$/s)?.[1];

export type IssueDefinition = Awaited<ReturnType<typeof generateIssue>>;

export const makeIssueReconciler = (createIssues: boolean, token: string) => {
  if (!createIssues) return async () => {};

  const octokit = github.getOctokit(token);

  const repo = {
    owner: github.context.repo.owner,
    repo: github.context.repo.repo,
  };

  const closeWithComment = async (
    issueNumber: number,
    comment: string,
    state_reason?: "completed" | "not_planned" | "reopened",
  ) => {
    await octokit.rest.issues.createComment({
      ...repo,
      issue_number: issueNumber,
      body: comment,
    });

    await octokit.rest.issues.update({
      ...repo,
      issue_number: issueNumber,
      state: "closed",
      state_reason,
    });
  };

  return async (desiredIssues: IssueDefinition[]) => {
    const currentIssues = await octokit.paginate(
      octokit.rest.issues.listForRepo,
      { ...repo, state: "open", labels: TODONE_LABEL },
    );

    core.debug(
      `Found ${currentIssues.length} open issues with label ${TODONE_LABEL}`,
    );

    const { trues: validCurrentIssues, falses: invalidCurrentIssues } =
      partition(
        currentIssues.map((issue) => {
          const id = (issue.body && getFinalData(issue.body)) || null;
          return id ? { type: "valid", id, issue } : { type: "invalid", issue };
        }),
        ({ type }) => type === "valid",
      );

    core.debug(
      `Found ${validCurrentIssues.length} valid issues and ${invalidCurrentIssues.length} invalid issues.`,
    );

    for (const {
      issue: { number },
    } of invalidCurrentIssues) {
      await closeWithComment(
        number,
        dedent`
          This issue has no valid ID recognized by todone, and will be closed.
          If this is an error, please remove the label \`${TODONE_LABEL}\` from this issue and re-open it.
        `,
        "not_planned",
      );
      core.info(`Closed issue #${number} due to invalid ID.`);
    }

    const currentIssuesMap = new Map(
      validCurrentIssues.map(({ id, issue }) => [id!, issue]),
    );

    const desiredIssuesMap = new Map(
      desiredIssues.map((issue) => [issue.id, issue]),
    );

    const reconciliation = reconcile(currentIssuesMap, desiredIssuesMap, [
      "body",
    ]);

    core.debug(dedent`
      Reconciliation result:
        Added: ${reconciliation.added.size},
        Removed: ${reconciliation.removed.size},
        Changes: ${reconciliation.changes.size}
    `);

    for (const { title, body } of reconciliation.added.values()) {
      const createdIssue = await octokit.rest.issues.create({
        ...repo,
        title,
        body,
        labels: [TODONE_LABEL],
      });
      core.info(`Created issue: #${createdIssue.data.number} ${title}`);
    }

    for (const { number } of reconciliation.removed.values()) {
      await closeWithComment(
        number,
        "The TODO referenced by this issue has been resolved, and it will be closed.",
        "completed",
      );
      core.info(`Closed issue #${number} as resolved.`);
    }

    for (const { current, changes } of reconciliation.changes.values()) {
      if (changes) {
        await octokit.rest.issues.update({
          ...repo,
          issue_number: current.number,
          ...changes,
        });
        core.info(`Updated issue #${current.number}`);
      } else {
        core.debug(`No changes for issue #${current.number}, skipping update.`);
      }
    }
  };
};
