import * as github from "@actions/github";
import { AnalysisItem } from "@todone/core";
import dedent from "dedent";

const TODONE_LABEL = "todone";

type ExpiredResult = AnalysisItem & {
  type: "result";
  result: { result: { isExpired: true } };
};

export const isExpiredResult = (item: AnalysisItem): item is ExpiredResult =>
  Boolean(
    item.type === "result" && item.result && item.result.result?.isExpired,
  );

export const generateIssue = ({
  result: { url, result, matches },
}: ExpiredResult) => {
  const urlString = url.toString();
  const title = result.title ?? `TODO: ${urlString}`;
  const body = dedent`
    The following TODO has expired${result.expirationDate ? ` as of ${result.expirationDate.toISOString()}` : ""}:

    ~~~
    ${[result.title, urlString].filter(Boolean).join("\n")}
    ~~~

    It is present in the following files:

    ${matches
      .map(
        (match) =>
          `- ${match.file}:L${match.position.line}-${match.position.column}`,
      )
      .join("\n")}

    ---

    This issue has been automatically created by ${"`todone`"}.

    <!-- Please do not edit this comment, it is automatically generated by todone. -->
    <!-- todone ${urlString} -->
  `;

  return { id: urlString, title, body };
};

const getFinalData = (txt: string) =>
  txt.match(/<!-- todone (.+) -->\s*$/s)?.[1];

export type IssueDefinition = ReturnType<typeof generateIssue>;

export const makeIssueReconciler = (createIssues: boolean, token: string) => {
  if (!createIssues) return async () => {};

  const octokit = github.getOctokit(token);

  const repo = {
    owner: github.context.repo.owner,
    repo: github.context.repo.repo,
  };

  const closeWithComment = async (
    issueNumber: number,
    comment: string,
    state_reason?: "completed" | "not_planned" | "reopened",
  ) => {
    await octokit.rest.issues.createComment({
      ...repo,
      issue_number: issueNumber,
      body: comment,
    });

    await octokit.rest.issues.update({
      ...repo,
      issue_number: issueNumber,
      state: "closed",
      state_reason,
    });
  };

  return async (issues: IssueDefinition[]) => {
    const newIssues = new Map(issues.map((issue) => [issue.id, issue]));
    const handledIssues = new Set<string>();

    for await (const { data: page } of octokit.paginate.iterator(
      octokit.rest.issues.listForRepo,
      { ...repo, state: "open", labels: TODONE_LABEL },
    )) {
      for (const existingIssue of page) {
        const id = getFinalData(existingIssue.body!);

        if (!id) {
          await closeWithComment(
            existingIssue.number,
            `This issue has no valid ID recognized by todone, and will be closed.

If this is an error, please remove the label "${TODONE_LABEL}" from this issue and re-open it.
`,
            "not_planned",
          );
        } else if (!newIssues.has(id)) {
          await closeWithComment(
            existingIssue.number,
            `The TODO referenced by this issue has been resolved, and it will be closed.
`,
            "completed",
          );
        } else {
          const newIssue = newIssues.get(id)!;
          await octokit.rest.issues.update({
            ...repo,
            issue_number: existingIssue.number,
            body: newIssue.body,
          });
          handledIssues.add(id);
        }
      }

      for (const [id, newIssue] of newIssues.entries()) {
        if (handledIssues.has(id)) continue;

        await octokit.rest.issues.create({
          ...repo,
          title: newIssue.title,
          body: newIssue.body,
          labels: [TODONE_LABEL],
        });
      }
    }
  };
};
