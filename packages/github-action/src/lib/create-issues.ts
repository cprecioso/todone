import * as github from "@actions/github";
import { toTransformStream } from "@std/streams";
import { AnalysisItem } from "@todone/core";
import * as s from "@todone/internal-util/stream";
import * as t from "@todone/types";

const TODONE_LABEL = "todone";

export const groupByMatchURL = (items: ReadableStream<AnalysisItem>) =>
  items
    .pipeThrough(
      s.compactMap((item) =>
        item.type === "result" && item.item.result && item.item.result.isExpired
          ? item.item
          : undefined,
      ),
    )
    .pipeThrough(
      toTransformStream(async function* (results) {
        const resultsByMatchURL = new Map<string, t.Result[]>();

        for await (const result of results) {
          const url = result.match.url.toString();

          let resultArray = resultsByMatchURL.get(url);
          if (!resultArray) {
            resultArray = [];
            resultsByMatchURL.set(url, resultArray);
          }

          resultArray.push(result);
        }

        yield* resultsByMatchURL.values();
      }),
    );

export const generateIssue = (results: t.Result[]) => {
  const result = results[0].result!;
  const url = results[0].match.url;

  const id = url.toString();
  const title = `TODO: ${id}`;
  const body = `The following TODO has expired${result.expirationDate ? ` as of ${result.expirationDate.toISOString()}` : ""}:

~~~
${result.title}
${url.toString()}
~~~

It is present in the following files:

${results
  .map(
    (item) =>
      `- ${item.match.file.location}:L${item.match.start.line}-${item.match.end.line}`,
  )
  .join("\n")}

---

This issue has been automatically created by ${"`todone`"}.

<!-- Please do not edit this comment, it is automatically generated by todone. -->
<!-- todone ${id} -->
`;

  return { id, title, body };
};

const getFinalData = (txt: string) =>
  txt.match(/<!-- todone (.+) -->\s*$/s)?.[1];

export type IssueDefinition = ReturnType<typeof generateIssue>;

export const makeIssueReconciler = (createIssues: boolean, token: string) => {
  if (!createIssues) return async () => {};

  const octokit = github.getOctokit(token);

  const repo = {
    owner: github.context.repo.owner,
    repo: github.context.repo.repo,
  };

  const closeWithComment = async (
    issueNumber: number,
    comment: string,
    state_reason?: "completed" | "not_planned" | "reopened",
  ) => {
    await octokit.rest.issues.createComment({
      ...repo,
      issue_number: issueNumber,
      body: comment,
    });

    await octokit.rest.issues.update({
      ...repo,
      issue_number: issueNumber,
      state: "closed",
      state_reason,
    });
  };

  return async (issues: IssueDefinition[]) => {
    const newIssues = new Map(issues.map((issue) => [issue.id, issue]));
    const handledIssues = new Set<string>();

    for await (const { data: page } of octokit.paginate.iterator(
      octokit.rest.issues.listForRepo,
      { ...repo, state: "open", labels: TODONE_LABEL },
    )) {
      for (const existingIssue of page) {
        const id = getFinalData(existingIssue.body!);

        if (!id) {
          await closeWithComment(
            existingIssue.number,
            `This issue has no valid ID recognized by todone, and will be closed.

If this is an error, please remove the label "${TODONE_LABEL}" from this issue and re-open it.
`,
            "not_planned",
          );
        } else if (!newIssues.has(id)) {
          await closeWithComment(
            existingIssue.number,
            `The TODO referenced by this issue has been resolved, and it will be closed.
`,
            "completed",
          );
        } else {
          const newIssue = newIssues.get(id)!;
          await octokit.rest.issues.update({
            ...repo,
            issue_number: existingIssue.number,
            body: newIssue.body,
          });
          handledIssues.add(id);
        }
      }

      for (const [id, newIssue] of newIssues.entries()) {
        if (handledIssues.has(id)) continue;

        await octokit.rest.issues.create({
          ...repo,
          title: newIssue.title,
          body: newIssue.body,
          labels: [TODONE_LABEL],
        });
      }
    }
  };
};
