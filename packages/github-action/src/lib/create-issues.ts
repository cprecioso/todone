import * as core from "@actions/core";
import * as github from "@actions/github";
import dedent from "dedent";
import pMap from "p-map";
import { reconcile } from "./reconciler";
import { ExpiredResult, partition } from "./util";

const TODONE_LABEL = "todone";

export const generateIssue = async ({
  result: { url, result, matches },
}: ExpiredResult) => {
  const urlString = url.toString();
  const title = `TODO: ${result.title ?? urlString}`;
  const body = dedent`
    The following TODO has expired${result.expirationDate ? ` as of ${result.expirationDate.toDateString()}` : ""}:

    ~~~
    ${[result.title, urlString].filter(Boolean).join("\n")}
    ~~~

    It is present in the following files:

    ${(
      await pMap(
        matches,
        async (match) =>
          `- ${(await match.file.getUrl(match.position.line)) || `${match.file.location}:${match.position.line}:${match.position.column}`}`,
        { concurrency: 1 },
      )
    ).join("\n")}

    ---

    This issue has been automatically created by ${"`todone`"}.

    <!-- Please do not edit this comment, it is automatically generated by todone. -->
    <!-- todone ${urlString} -->
  `;

  return { id: urlString, title, body };
};

const getFinalData = (txt: string) =>
  txt.match(/<!-- todone (.+) -->\s*$/s)?.[1];

export type IssueDefinition = Awaited<ReturnType<typeof generateIssue>>;

export const makeIssueReconciler = (createIssues: boolean, token: string) => {
  if (!createIssues) return async () => {};

  const octokit = github.getOctokit(token);

  const repo = {
    owner: github.context.repo.owner,
    repo: github.context.repo.repo,
  };

  const closeWithComment = async (
    issueNumber: number,
    comment: string,
    state_reason?: "completed" | "not_planned" | "reopened",
  ) => {
    await octokit.rest.issues.createComment({
      ...repo,
      issue_number: issueNumber,
      body: comment,
    });

    await octokit.rest.issues.update({
      ...repo,
      issue_number: issueNumber,
      state: "closed",
      state_reason,
    });
  };

  return async (desiredIssues: IssueDefinition[]) => {
    const currentIssues = await octokit.paginate(
      octokit.rest.issues.listForRepo,
      { ...repo, state: "open", labels: TODONE_LABEL },
    );

    core.debug(
      `Found ${currentIssues.length} open issues with label ${TODONE_LABEL}`,
    );

    const { trues: validCurrentIssues, falses: invalidCurrentIssues } =
      partition(
        currentIssues.map((issue) => {
          const id = (issue.body && getFinalData(issue.body)) || null;
          return id ? { type: "valid", id, issue } : { type: "invalid", issue };
        }),
        ({ type }) => type === "valid",
      );

    core.debug(
      `Found ${validCurrentIssues.length} valid issues and ${invalidCurrentIssues.length} invalid issues.`,
    );

    for (const {
      issue: { number },
    } of invalidCurrentIssues) {
      await closeWithComment(
        number,
        dedent`
          This issue has no valid ID recognized by todone, and will be closed.
          If this is an error, please remove the label \`${TODONE_LABEL}\` from this issue and re-open it.
        `,
        "not_planned",
      );
      core.info(`Closed issue #${number} due to invalid ID.`);
    }

    const currentIssuesMap = new Map(
      validCurrentIssues.map(({ id, issue }) => [id!, issue]),
    );

    const desiredIssuesMap = new Map(
      desiredIssues.map((issue) => [issue.id, issue]),
    );

    const reconciliation = reconcile(currentIssuesMap, desiredIssuesMap, [
      "body",
    ]);

    core.debug(dedent`
      Reconciliation result:
        Added: ${reconciliation.added.size},
        Removed: ${reconciliation.removed.size},
        Changes: ${reconciliation.changes.size}
    `);

    for (const { title, body } of reconciliation.added.values()) {
      const createdIssue = await octokit.rest.issues.create({
        ...repo,
        title,
        body,
        labels: [TODONE_LABEL],
      });
      core.info(`Created issue: #${createdIssue.data.number} ${title}`);
    }

    for (const { number } of reconciliation.removed.values()) {
      await closeWithComment(
        number,
        "The TODO referenced by this issue has been resolved, and it will be closed.",
        "completed",
      );
      core.info(`Closed issue #${number} as resolved.`);
    }

    for (const { current, changes } of reconciliation.changes.values()) {
      if (changes) {
        await octokit.rest.issues.update({
          ...repo,
          issue_number: current.number,
          ...changes,
        });
        core.info(`Updated issue #${current.number}`);
      } else {
        core.debug(`No changes for issue #${current.number}, skipping update.`);
      }
    }
  };
};
